	
//			if (maxDist > l){
//				
//				if (centers1.getSize() == 2 && centers2.getSize() == 2){
//					LineSegment line1 = new LineSegment(centers1.points.get(0), centers1.points.get(1));
//					LineSegment line2 = new LineSegment(centers2.points.get(0), centers2.points.get(1));
//					
//					if (line1.isHorizontal() && line2.isHorizontal()){
//						for(double i = line1.start.posX; i < line1.end.posX; i++){
//							for(double j = line2.start.posX; j < line2.end.posX; j++){
//								Point p1 = new Point(i, line1.start.posY);
//								Point p2 = new Point(j, line2.start.posY);
//								if (p1.distanceSquaredTo(p2) == l){
//									currentFacility = p1;
//									currentTurnpikeStart = p2;
//									currentRadius = Math.max(list1.delta() + e2 + x, list2.delta() + e1 + x);
//									System.out.println(currentFacility.distanceSquaredTo(currentTurnpikeStart));
//									lengthFound = true;
//								}if (lengthFound) break;
//							}if (lengthFound) break;
//							
//						} if (lengthFound) break;
//					} else if (line1.isHorizontal() && line2.isVertical()){
//						for(double i = line1.start.posX; i < line1.end.posX; i++){
//							for(double j = line2.start.posY; j < line2.end.posY; j++){
//								Point p1 = new Point(i, line1.start.posY);
//								Point p2 = new Point(line2.start.posX, j);
//								if (p1.distanceSquaredTo(p2) == l){
//									currentFacility = p1;
//									currentTurnpikeStart = p2;
//									currentRadius = Math.max(list1.delta() + e2 + x, list2.delta() + e1 + x);
//									System.out.println(currentFacility.distanceSquaredTo(currentTurnpikeStart));
//									lengthFound = true;
//								}if (lengthFound) break;
//							}if (lengthFound) break;
//							
//						}if (lengthFound) break;
//					} else if (line1.isVertical() && line2.isHorizontal()){
//						for(double i = line1.start.posY; i < line1.end.posY; i++){
//							for(double j = line2.start.posX; j < line2.end.posX; j++){
//								Point p1 = new Point(line1.start.posX, i);
//								Point p2 = new Point(j, line2.start.posY);
//								if (p1.distanceSquaredTo(p2) == l){
//									currentFacility = p1;
//									currentTurnpikeStart = p2;
//									currentRadius = Math.max(list1.delta() + e2 + x, list2.delta() + e1 + x);
//									System.out.println(currentFacility.distanceSquaredTo(currentTurnpikeStart));
//									lengthFound = true;
//								}if (lengthFound) break;
//							}if (lengthFound) break;
//							
//						}if (lengthFound) break;
//					} else if (line1.isVertical() && line2.isVertical()){
//						for(double i = line1.start.posY; i < line1.end.posY; i++){
//							for(double j = line2.start.posY; j < line2.end.posY; j++){
//								Point p1 = new Point(line1.start.posX, i);
//								Point p2 = new Point(line2.start.posX, j);
//								if (p1.distanceSquaredTo(p2) == l){
//									currentFacility = p1;
//									currentTurnpikeStart = p2;
//									currentRadius = Math.max(list1.delta() + e2 + x, list2.delta() + e1 + x);
//									System.out.println(currentFacility.distanceSquaredTo(currentTurnpikeStart));
//									lengthFound = true;
//									
//								}if (lengthFound) break;
//							}if (lengthFound) break;
//							
//						}
//					}if (lengthFound) break;
//				}
//				
//				if (centers1.getSize() == 4 && centers2.getSize() == 2){
//					Rect rect = new Rect(centers1.points.get(0),
//							Math.abs(centers1.points.get(2).posX-centers1.points.get(0).posX), 
//							Math.abs(centers1.points.get(1).posY-centers1.points.get(0).posY));
//					LineSegment line = new LineSegment(centers2.points.get(0), centers2.points.get(1));
//					if (line.isHorizontal()){
//						for(double i = line.start.posX; i < line.end.posX; i++){
//							for(double j = rect.leftUpperVertex.posX; j < rect.rightUpperVertex.posX; j++){
//								for (double k = rect.leftUpperVertex.posY; k < rect.leftLowerVertex.posY; k++){
//									Point p1 = new Point(i, line.start.posY);
//									Point p2 = new Point(j,k);
//									if (p1.distanceSquaredTo(p2) == l){
//										currentFacility = p1;
//										currentTurnpikeStart = p2;
//										currentRadius = Math.max(list1.delta() + e2 + x, list2.delta() + e1 + x);
//										System.out.println(currentFacility.distanceSquaredTo(currentTurnpikeStart));
//										lengthFound = true;
//									}if (lengthFound) break;
//								}if (lengthFound) break;
//							}if (lengthFound) break;
//						}if (lengthFound) break;
//					} else if (line.isVertical()){
//						for(double i = line.start.posY; i < line.end.posY; i++){
//							for(double j = rect.leftUpperVertex.posX; j < rect.rightUpperVertex.posX; j++){
//								for (double k = rect.leftUpperVertex.posY; k < rect.leftLowerVertex.posY; k++){
//									Point p1 = new Point(line.start.posX, i);
//									Point p2 = new Point(j,k);
//									if (p1.distanceSquaredTo(p2) == l){
//										currentFacility = p1;
//										currentTurnpikeStart = p2;
//										currentRadius = Math.max(list1.delta() + e2 + x, list2.delta() + e1 + x);
//										System.out.println(currentFacility.distanceSquaredTo(currentTurnpikeStart));
//										lengthFound = true;
//									}if (lengthFound) break;
//								}if (lengthFound) break;
//							}if (lengthFound) break;
//						}
//					
//					}if (lengthFound) break;
//				}
//				
//				if (centers1.getSize() == 2 && centers2.getSize() == 4){
//					Rect rect = new Rect(centers2.points.get(0),
//							Math.abs(centers2.points.get(2).posX-centers2.points.get(0).posX), 
//							Math.abs(centers2.points.get(1).posY-centers2.points.get(0).posY));
//					LineSegment line = new LineSegment(centers1.points.get(0), centers1.points.get(1));
//					if (line.isHorizontal()){
//						for(double i = line.start.posX; i < line.end.posX; i++){
//							for(double j = rect.leftUpperVertex.posX; j < rect.rightUpperVertex.posX; j++){
//								for (double k = rect.leftUpperVertex.posY; k < rect.leftLowerVertex.posY; k++){
//									Point p1 = new Point(i, line.start.posY);
//									Point p2 = new Point(j,k);
//									if (p1.distanceSquaredTo(p2) == l){
//										currentFacility = p1;
//										currentTurnpikeStart = p2;
//										currentRadius = Math.max(list1.delta() + e2 + x, list2.delta() + e1 + x);
//										System.out.println(currentFacility.distanceSquaredTo(currentTurnpikeStart));
//										lengthFound = true;
//									}if (lengthFound) break;
//								}if (lengthFound) break;
//							}if (lengthFound) break;
//						}if (lengthFound) break;
//					} else if (line.isVertical()){
//						for(double i = line.start.posY; i < line.end.posY; i++){
//							for(double j = rect.leftUpperVertex.posX; j < rect.rightUpperVertex.posX; j++){
//								for (double k = rect.leftUpperVertex.posY; k < rect.leftLowerVertex.posY; k++){
//									Point p1 = new Point(line.start.posX, i);
//									Point p2 = new Point(j,k);
//									if (p1.distanceSquaredTo(p2) == l){
//										currentFacility = p1;
//										currentTurnpikeStart = p2;
//										currentRadius = Math.max(list1.delta() + e2 + x, list2.delta() + e1 + x);
//										System.out.println(currentFacility.distanceSquaredTo(currentTurnpikeStart));
//										lengthFound = true;
//									}if (lengthFound) break;
//								}if (lengthFound) break;
//							}if (lengthFound) break;
//						}
//					}if (lengthFound) break;
//				}
//				
//				if (centers1.getSize() == 4 && centers2.getSize() == 4){
//					System.out.println("4-4");
//					Rect rect1 = new Rect(centers1.points.get(0),
//							Math.abs(centers1.points.get(2).posX-centers1.points.get(0).posX), 
//							Math.abs(centers1.points.get(1).posY-centers1.points.get(0).posY));
//					Rect rect2 = new Rect(centers2.points.get(0),
//							Math.abs(centers2.points.get(2).posX-centers2.points.get(0).posX), 
//							Math.abs(centers2.points.get(1).posY-centers2.points.get(0).posY));
//					
//					for(double h = rect1.leftUpperVertex.posX; h < rect1.rightUpperVertex.posX; h++){
//						for(double i = rect1.leftUpperVertex.posY; i < rect1.leftLowerVertex.posY; i++){
//							for(double j = rect2.leftUpperVertex.posX; j < rect2.rightUpperVertex.posX; j++){
//								for (double k = rect2.leftUpperVertex.posY; k < rect2.leftLowerVertex.posY; k++){
//									Point p1 = new Point(h,i);
//									Point p2 = new Point(j,k);
//									if (p1.distanceSquaredTo(p2) == l){
//										currentFacility = p1;
//										currentTurnpikeStart = p2;
//										currentRadius = Math.max(list1.delta() + e2 + x, list2.delta() + e1 + x);
//										System.out.println(currentFacility.distanceSquaredTo(currentTurnpikeStart));
//										lengthFound = true;
//									}if (lengthFound) break;
//								}if (lengthFound) break;
//							}if (lengthFound) break;
//						}if (lengthFound) break;
//					}if (lengthFound) break;
//				}
					
					
						//there are possible positions for f,t
					
//					if (centers1.getSize() == 2 && centers2.getSize() == 2){
//						// two line segments
//						
//						LineSegment line1 = new LineSegment(centers1.points.get(0), centers1.points.get(1));
//						LineSegment line2 = new LineSegment(centers2.points.get(0), centers2.points.get(1));
//						
//						Hashtable<Double, Point[]> distSeg = new Hashtable<Double, Point[]>();
//						distSeg = line1.distanceTo(line2);
//						minDist = (double) distSeg.keySet().toArray()[0]; // min dist between line 1, line 2
////						Point[] minDistPoints = new Point[2];
//						minDistPoints = new Point[2];
//						minDistPoints = distSeg.get(minDist); // points spanning min dist on line 1, line 2
//						
//						if (Math.pow(minDist, 2.0) <= l){
//						// Points that span min distance between two segments
//							
//							Point a = minDistPoints[0]; // = end point of one of the segments
//							Point b = minDistPoints[1];
//							Point c;
//							Point d;
//							
//							if (line1.contains(b)) {
//								c = distances.get(maxDist)[0];
//								if (!line1.contains(c)) c = distances.get(maxDist)[1];
//								LineSegment bcSegment = new LineSegment(b, c);
//								double bcVectorLength = bcSegment.getSquaredLength();
//								double deltaPos = - minDist + Math.sqrt(l - bcVectorLength);
//								double deltaNeg = - minDist - Math.sqrt(l - bcVectorLength);
//								double[] dir;
//								if (a.equals(line2.start)){
//									dir = a.getDirectionVectorTo(line2.end);
//								} else dir = a.getDirectionVectorTo(line2.start);
//								d = new Point(a.posX + deltaPos * dir[0], a.posY + deltaPos * dir[1],Color.GREEN);
//								
//								currentTurnpikeStart = c;
//								currentTurnpikeStart.setColor(Color.MAGENTA);
//								currentFacility = d;
//								System.out.println("pos1: " + currentFacility.distanceSquaredTo(currentTurnpikeStart));
//								lengthFound = true;
//							} else if (line2.contains(b)) {
//								c = distances.get(maxDist)[1];
//								if (!line2.contains(c)) c = distances.get(maxDist)[0];
//								LineSegment bcSegment = new LineSegment(b, c);
//								double bcVectorLength = bcSegment.getSquaredLength();
//								double deltaPos = - minDist + Math.sqrt(l - bcVectorLength);
//								double deltaNeg = - minDist - Math.sqrt(l - bcVectorLength);
//								
//								double[] dir;
//								if (a.equals(line1.start)){
//									dir = a.getDirectionVectorTo(line1.end);
//								} else dir = a.getDirectionVectorTo(line1.start);
//								
//								d = new Point(a.posX + deltaPos * dir[0], a.posY + deltaPos * dir[1],Color.GREEN);
//								
//								currentTurnpikeStart = c;
//								currentTurnpikeStart.setColor(Color.MAGENTA);
//								currentFacility = d;
//								
//								System.out.println("delta: " + deltaPos);
//								System.out.println("minDist: " + (- minDist));
//								System.out.println(bcVectorLength);
//								System.out.println(a.posX + deltaPos * dir[0]);
//								System.out.println(a.posY + deltaPos * dir[1]);
//								System.out.println("pos2: " + currentFacility.distanceSquaredTo(currentTurnpikeStart));
//								lengthFound = true;
//							}
//						}
							
//							
//							double addXNeg = - (b.posX - a.posX) - Math.sqrt(Math.pow(highWayLength, 2.0) - Math.pow(b.posY - a.posY, 2.0));
//							double addXPos = - (b.posX - a.posX) + Math.sqrt(Math.pow(highWayLength, 2.0) - Math.pow(b.posY - a.posY, 2.0));
//							double[] direction = b.getDirectionVectorTo(c);
//							currentTurnpikeStart = a;
//							currentTurnpikeStart.setColor(Color.MAGENTA);
//							currentRadius = Math.max(list1.delta() + e2 + x, list2.delta() + e1 + x);
//							currentFacility = new Point(b.posX + addXNeg * direction[0], b.posY + addXNeg * direction[1],Color.GREEN);
//							System.out.println("neg: " + currentFacility.distanceSquaredTo(currentTurnpikeStart));
//							currentFacility = new Point(b.posX + addXPos * direction[0], b.posY + addXPos * direction[1],Color.GREEN);
//							System.out.println("pos: " + currentFacility.distanceSquaredTo(currentTurnpikeStart));
//							
							
//						}
						
						
//					}
//				}	